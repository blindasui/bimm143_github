install.packages("BiocManager")
BiocManager::install("DESeq2")
n
library(DESeq2)
#Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
head(counts)
nrow(counts)
metadata
nrow(metadata)
ncol(counts)
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4
head(control.mean)
control <- metadata[metadata[,"dex"]=="control",]
control <- metadata[metadata[,"dex"]=="control",]
head(control)
control <- metadata[metadata[,"dex"]=="control",]
nrow(control)
sum(metadata$dex == "control")
metadata
metadata$control
metadata$dex == "control"
control.inds <- metadata$dex == "control"
counts[,control.inds]
control.inds <- metadata$dex == "control"
control.counts <- counts[,control.inds]
control.inds <- metadata$dex == "control"
control.counts <- counts[,control.inds]
control.mean <- rowSums( control.counts )/4
head(control.mean)
control.inds <- metadata$dex == "control"
control.counts <- counts[,control.inds]
rowMeans(control.counts)
control.means <- rowMeans(control.counts)
control.means <- rowMeans(control.counts)
control.means
#2
control.means <- rowMeans(control.counts)
control.means
#3-4
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[,treated.inds]
View(control.counts)
#2
control.means <- rowMeans(control.counts)
#3-4
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[,treated.inds]
treated.means <- rowMeans(treated.counts)
#2
control.means <- rowMeans(control.counts)
#3-4
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[,treated.inds]
treated.means <- rowMeans(counts[, metadata$dex == "treated")
#2
control.means <- rowMeans(control.counts)
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
meancounts <- data.frame(control.means, treated.means)
head(meancounts)
plot(meancounts)
plot(meancounts, log="xy")
# control/treated
log(10/10)
log2(10/20)
log2(10/20)
log2(20/10)
log2(10/40)
log2(40/10)
log2(10/40)
log2(meancounts$treated.means/
meancounts$control.means)
head(meancounts)
meancounts$log2(meancounts$treated.means/
meancounts$control.means)
sum(meancounts$log2fc > +2, na.rm=T)
meancounts$log2fc(meancounts$treated.means/
meancounts$control.means)
meancounts$log2fc <- log2(meancounts$treated.means/
meancounts$control.means)
head(meancounts)
sum(meancounts$log2fc >= +2, na.rm=T)
sum(meancounts$log2fc <= -2, na.r=T)
sum(meancounts$log2fc <= -2, na.r=T)
sum(meancounts$log2fc <= -2, na.r=T)
sum(meancounts$log2fc <= -2, na.rm=T)
library(DESeq2)
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = metadata,
design = ~dex)
dds <- DESeq(dds)
results(dds)
res <- results(dds)
head(res)
36000 * 0.05
plot(res$log2FoldChange)
plot(res$log2FoldChange, res$padj)
plot(res$log2FoldChange, -log(res$padj))
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
#abline() function in R is used to add one or more straight lines to an existing plot. It is a powerful tool for enhancing data visualization by highlighting trends, relationships, or specific reference points within your data.
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.05))
#abline() function in R is used to add one or more straight lines to an existing plot. It is a powerful tool for enhancing data visualization by highlighting trends, relationships, or specific reference points within your data.
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.04), col="red")
#abline() function in R is used to add one or more straight lines to an existing plot. It is a powerful tool for enhancing data visualization by highlighting trends, relationships, or specific reference points within your data.
write.csv(res, file="my_results.csv")
nrow(counts)
#2
control.means <- rowMeans(control.counts)
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
#2
control.means <- rowMeans(control.counts)
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
#2
control.means <- rowMeans(control.counts)
control.means
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
treated.means
#2
control.means <- rowMeans(control.counts)
control.means
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
treated.means
plot(meancounts, log="xy")
plot(meancounts, log="xy")
plot(meancounts)
#5
meancounts <- data.frame(control.means, treated.means)
head(meancounts)
plot(meancounts)
plot(meancounts, log="xy")
ggplot(df, aes(x = control.mean, y = treated.mean)) +
geom_point()
ggplot(meancounts, aes(x = control.mean, y = treated.mean)) +
geom_point()
library(ggplot2)
ggplot(meancounts, aes(x = control.mean, y = treated.mean)) +
geom_point()
library(tidyverse)
ggplot(meancounts, aes(x = control.mean, y = treated.mean)) +
geom_point()
library(tidyverse)
ggplot(meancounts, aes(x = control.means, y = treated.means)) +
geom_point()
# treated/control
log2(10/10)
log2(10/20)
log2(20/10)
log2(40/10)
log2(10/40)
meancounts$log2fc <- log2(meancounts$treated.means/
meancounts$control.means)
head(meancounts)
sum(meancounts$log2fc >= +2, na.rm=T)
#When na.rm is set to TRUE, the function will remove or ignore any NA values present in the input data before performing the calculation. If na.rm is set to FALSE (which is often the default), and there are NA values in the data, the function will typically return NA as the result, as it cannot compute a meaningful value when missing data is present.
plot(control.mean, treated.mean, log = "xy")
plot(control.means, treated.means, log = "xy")
plot(control.means, treated.means, log = "xy")
up.ind <- mycounts$log2fc > 2
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind, down.ind)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind)
sum(down.ind)
sum(meancounts$log2fc <= -2, na.rm=T)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind)
sum(down.ind)
meancounts$log2fc <- log2(meancounts$treated.means/
meancounts$control.means)
head(meancounts)
sum(meancounts$log2fc >= +2, na.rm=T)
#When na.rm is set to TRUE, the function will remove or ignore any NA values present in the input data before performing the calculation. If na.rm is set to FALSE (which is often the default), and there are NA values in the data, the function will typically return NA as the result, as it cannot compute a meaningful value when missing data is present.
sum(meancounts$log2fc <= -2, na.rm=T)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind)
sum(down.ind)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind)
sum(down.ind)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
up.ind
down.ind
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind)
sum(down.ind)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
up.ind
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind, na.rm=T)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind, na.rm=T)
sum(down.ind, na.rm=T)
#Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
head(counts)
nrow(counts)
nrow(metadata)
sum(metadata$dex == "control")
#1
control.inds <- metadata$dex == "control"
control.counts <- counts[,control.inds]
#2
control.means <- rowMeans(control.counts)
control.means
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
treated.means
#5
meancounts <- data.frame(control.means, treated.means)
head(meancounts)
plot(meancounts)
plot(meancounts, log="xy")
library(tidyverse)
ggplot(meancounts, aes(x = control.means, y = treated.means)) +
geom_point()
plot(control.means, treated.means, log = "xy")
# treated/control
log2(10/10)
log2(10/20)
log2(20/10)
log2(40/10)
log2(10/40)
meancounts$log2fc <- log2(meancounts$treated.means/
meancounts$control.means)
head(meancounts)
sum(meancounts$log2fc >= +2, na.rm=T)
#When na.rm is set to TRUE, the function will remove or ignore any NA values present in the input data before performing the calculation. If na.rm is set to FALSE (which is often the default), and there are NA values in the data, the function will typically return NA as the result, as it cannot compute a meaningful value when missing data is present.
sum(meancounts$log2fc <= -2, na.rm=T)
up.ind <- meancounts$log2fc > 2
down.ind <- meancounts$log2fc < (-2)
sum(up.ind, na.rm=T)
sum(down.ind, na.rm=T)
library(DESeq2)
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = metadata,
design = ~dex)
dds <- DESeq(dds)
res <- results(dds)
head(res)
36000 * 0.05
plot(res$log2FoldChange, -log(res$padj))
abline(v=c(-2,2), col="red")
abline(h=-log(0.04), col="red")
#abline() function in R is used to add one or more straight lines to an existing plot. It is a powerful tool for enhancing data visualization by highlighting trends, relationships, or specific reference points within your data.
write.csv(res, file="my_results.csv")
#2
control.means <- rowMeans(control.counts)
#3-4
treated.means <- rowMeans(counts[, metadata$dex == "treated"])
